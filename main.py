"""Скрипт подсчёта зарплаты сотрудников


file_1  ->  [             ]  ->  [              ]  ->  [          ]  -> close
file_2  ->  [ data_to_obj ]  ->  [ filter_by_id ]  ->  [ group_by ]  -> close
...     ->  [             ]  ->  [              ]  ->  [          ]  -> close


{
    "Design": {
        "Alice": {
            "hours": 150,
            "rate": 40,
            "payout": $6000,
        },
        "__report__": {
            "hours": sum(*),
            "payout": sum(*),
        }
    }
}
"""

import os
import abc
import enum
import json
import typing
import argparse
from collections import defaultdict
from dataclasses import dataclass


class ReportFileFormatsEnum(str, enum.Enum):
    JSON = "JSON"


ReportFileDataType = dict[str, dict[str, dict[str, int]]]


class AbcExportReader(abc.ABC):
    @abc.abstractmethod
    def __init__(self, filepath: str):
        """Initiates the export reader

        :param filepath: str, Export filepath to stream
        :returns: None
        """

    @abc.abstractmethod
    def stream(self) -> typing.Generator[list[str], None, None]:
        """Streams export file

        :param filepath: str, Export filepath to stream
        :yields: Generator[list[str], None, None], Yields the data
        :returns: None
        """


class AbcReportWriter(abc.ABC):
    @abc.abstractmethod
    def __init__(self, filename: str):
        """Initiates the report writer

        :param filename: str, Report filename
        :returns: None
        """

    @abc.abstractmethod
    def write(self, data: ReportFileDataType) -> None:
        """Writes report to file

        :param data: dict[str, dict], Report data to write
        :returns: None
        """


class CSVExportReader(AbcExportReader):
    DATA_DELIMITER: str = ","

    def __init__(self, filepath: str):
        self.filepath = filepath

    def stream(self):
        with open(self.filepath) as ftr:
            for line in ftr.read().split("\n"):
                line = line.strip()
                if not line:
                    continue
                yield line.split(self.DATA_DELIMITER)


class JSONReportWriter(AbcReportWriter):
    FILE_EXT: str = ".json"

    def __init__(self, filename: str):
        self.filename = os.path.splitext(filename)[0] + self.FILE_EXT

    def write(self, data: ReportFileDataType):
        with open(self.filename, "w") as ftw:
            json.dump(data, ftw, indent=2)


@dataclass
class Employee:
    id: str
    name: str
    email: str
    department: str
    hours: int  # type: ignore
    rate: int  # type: ignore

    @property  # type: ignore
    def hours(self) -> int:
        return self._hours

    @hours.setter
    def hours(self, value: str) -> None:
        # NOTE (ames0k0): No type checking
        self._hours = int(value)

    @property  # type: ignore
    def rate(self) -> int:
        return self._rate

    @rate.setter
    def rate(self, value: str) -> None:
        # NOTE (ames0k0): No type checking
        self._rate = int(value)

    def payout(self) -> int:
        """Returns the employee payout"""
        return self.hours * self.rate


class Data2Object:
    COLUMNS_NAMES_TO_MATCH: dict[str, str] = {
        "id": "id",
        "name": "name",
        "email": "email",
        "department": "department",
        "hours_worked": "hours",
        "rate": "rate",
        "hourly_rate": "rate",
        "salary": "rate",
    }

    def __init__(self):
        self.data_order: dict[int, str] = dict()

    def match_columns(self, columns: list[str]) -> None:
        """Matching given columns name with the expected columns name

        :param columns: list[str], Column names to match
        :return: None
        :raises: ValueError, For not matched expected columns name
        """
        for index, column in enumerate(columns):
            # XXX (ames0k0): Ищем только нужных колонок
            if column not in self.COLUMNS_NAMES_TO_MATCH:
                continue
            self.data_order[index] = self.COLUMNS_NAMES_TO_MATCH[column]
        columns_diff = set(self.COLUMNS_NAMES_TO_MATCH.values()).difference(
            self.data_order.values()
        )
        if columns_diff:
            raise ValueError("Отсутствуют колонки:", columns_diff)

    def dump(self, data: list[str]) -> Employee:
        """Returns `Employee` object generated by the given data"""
        values = {}
        for index, value in enumerate(data):
            values[self.data_order[index]] = value.strip()
        return Employee(**values)  # type: ignore


class Report:
    def __init__(
        self,
        export_files: typing.Sequence[str],
        report_filename: str,
        report_file_format: ReportFileFormatsEnum,
    ):
        self.export_files_reader = self.get_export_files_reader(
            export_files=export_files,
        )
        self.report_file_writer = self.get_report_file_writer(
            report_filename=report_filename,
            report_file_format=report_file_format,
        )
        self.loaded_employees_id: set[str] = set()
        self.departments_and_employees: dict[
            str,
            list[Employee],
        ] = defaultdict(list)

    def get_export_files_reader(
        self,
        export_files: typing.Sequence[str],
    ) -> list[CSVExportReader]:
        """Returns file reader objects

        :param export_files: list[str], Export filepaths to read
        :returns: typing.Union[CSVExportReader], Reader objects
        """
        files_reader: list[CSVExportReader] = list()

        for export_file in set(export_files):
            if not os.path.exists(export_file):
                raise FileNotFoundError("Файл не найден: %s" % export_file)

            _, ext = os.path.splitext(export_file)
            if ext == ".csv":
                files_reader.append(
                    CSVExportReader(
                        filepath=export_file,
                    )
                )
            else:
                raise ValueError("Чтение файла не поддерживает: %s" % ext)

        return files_reader

    def get_report_file_writer(
        self,
        report_filename: str,
        report_file_format: ReportFileFormatsEnum,
    ):
        if report_file_format == ReportFileFormatsEnum.JSON:
            return JSONReportWriter(filename=report_filename)
        else:
            raise ValueError(
                "Запись файла не поддерживает: %s" % report_file_format,
            )

    def group_employees_by_department(
        self,
        file_reader: CSVExportReader,
    ) -> None:
        """Groups employees by `department`

        :param file_reader: typing.Union[CSVExportReader], Reader object
        :returns: None
        """
        rows = file_reader.stream()
        data_to_object = Data2Object()
        data_to_object.match_columns(columns=next(rows))
        for row in rows:
            employee = data_to_object.dump(row)
            if employee.id in self.loaded_employees_id:
                print("Duplicated data for employee_id:", employee.id)
                continue
            self.loaded_employees_id.add(employee.id)
            self.departments_and_employees[employee.department].append(
                employee,
            )

    def generate(self) -> None:
        result: dict[str, dict[str, dict[str, int]]] = dict()

        for file_reader in self.export_files_reader:
            self.group_employees_by_department(file_reader=file_reader)

        for department, employees in self.departments_and_employees.items():
            report_per_department: dict[str, dict[str, int]] = dict()
            sum_hours: int = 0
            sum_payout: int = 0
            for employee in employees:
                report_per_department[employee.name] = {
                    "hours": employee.hours,
                    "rate": employee.rate,
                    "payout": employee.payout(),
                }
                sum_hours += report_per_department[employee.name]["hours"]
                sum_payout += report_per_department[employee.name]["payout"]

            report_per_department["__report__"] = {
                "hours": sum_hours,
                "payout": sum_payout,
            }
            result[department] = report_per_department

        self.report_file_writer.write(data=result)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        prog=__file__,
        description="\n".join(
            (
                "Скрипт подсчёта зарплаты сотрудников\n",
                "Поддерживает чтение файлов: .csv",
                "Поддерживает запись файлов: .json",
            )
        ),
        usage="python main.py [export_file]... --report [report_filename]",
        epilog="python main.py data1.csv data2.csv data3.csv --report payout",
        formatter_class=argparse.RawTextHelpFormatter,
    )
    parser.add_argument("--report", help="Report filename")

    args, export_files = parser.parse_known_args()

    if not args.report:
        parser.print_help()
        exit(1)

    report = Report(
        export_files=export_files,
        report_filename=args.report,
        report_file_format=ReportFileFormatsEnum.JSON,
    )
    report.generate()
